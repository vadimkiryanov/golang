// Package racecondition демонстрирует работу с конкурентным доступом к общим данным
package racecondition

import (
	"fmt"
	"sync"
	"time"
)

// counter представляет собой безопасный для конкурентного использования счетчик
// value - значение счетчика
// mutx - указатель на мьютекс для синхронизации доступа к value
type counter struct {
	value int
	mutx  *sync.Mutex
}

// increment увеличивает значение счетчика на 1
// Метод использует мьютекс для защиты от одновременного доступа нескольких горутин
// Lock() блокирует доступ другим горутинам до вызова Unlock()
func (c *counter) increment() {
	c.mutx.Lock()   // Захватываем мьютекс
	c.value++       // Увеличиваем значение (критическая секция)
	c.mutx.Unlock() // Освобождаем мьютекс
}

// getValue возвращает текущее значение счетчика
// Метод также защищен мьютексом, так как чтение должно быть атомарным
// defer гарантирует, что мьютекс будет разблокирован даже при возникновении паники
func (c *counter) getValue() int {
	c.mutx.Lock()         // Захватываем мьютекс
	defer c.mutx.Unlock() // Освобождаем мьютекс при выходе из функции
	return c.value
}

// Main демонстрирует работу конкурентного счетчика
func Main() {
	// Инициализируем счетчик
	var counterInit = counter{
		value: 0,
		mutx:  new(sync.Mutex), // Создаем новый мьютекс
	}

	// Запускаем 1000 горутин, каждая из которых увеличивает счетчик
	for i := 0; i < 1000; i++ {
		go func() {
			counterInit.increment()
		}()
	}

	// Ждем секунду, чтобы все горутины успели выполниться
	// Примечание: это не самый надежный способ синхронизации,
	// лучше использовать sync.WaitGroup
	time.Sleep(time.Second)

	// Выводим финальное значение счетчика
	fmt.Println("counter = ", counterInit.getValue())
}
